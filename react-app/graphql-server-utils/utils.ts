import fetch from "isomorphic-fetch"
import { PostgresMetadataQueryResult } from "./types/sql-query-results"
import { PreparedQuery } from "@pgtyped/query"

/**
 * Takes one of the query functions generated by @pgtyped (located in ./sql-queries)
 * and a Metadata client created with createHasuraMetadataClient(), and returns a strongly-typed
 * response by delegating to runSQL() but casting the result as the query return type
 *
 * This is because @pgtyped does not allow configuring only type definitions, and requires a DB driver for the query functions
 * so this sort of hacky wrapper that just types a delegated HTTP SQL query from the API was the best solution I had
 */
export function sqlQuery<T extends PreparedQuery<any, any>>(params: {
  query: T
  metadataClientQuery: ReturnType<typeof createHasuraMetadataClient>
}): ReturnType<T["run"]> {
  return runSQL(
    params.metadataClientQuery,
    params.query["query"]["statement"]["body"]
  ) as ReturnType<T["run"]>
}

/**
 * Runs a SQL query using a client for querying the /v1/query API
 * and then uses a serializing function to convert the tuple result to regular
 * arrays of objects
 */
export async function runSQL(
  metadataClientQuery: ReturnType<typeof createHasuraMetadataClient>,
  query: string
) {
  const request = await metadataClientQuery({
    type: "run_sql",
    args: {
      sql: query,
    },
  })
  const response = await request.json()
  return convertRunSQLTuplesToArrayOfObjects(response.result)
}

/**
 * @example
 * const request = await fetch('http://localhost:8080/v1/query', {
 *   method: 'POST',
 *   body: JSON.stringify({
 *     type: 'run_sql',
 *     args: {
 *       sql: `
 *         select *
 *         from information_schema.columns
 *         where table_schema = 'public'
 *       `
 *     },
 *   })
 * })
 *
 * const data = await request.json()
 * convertRunSQLTuplesToArrayOfObjects(data.result)
 **/
export function convertRunSQLTuplesToArrayOfObjects(tuples: string[][]) {
  const results: Record<string, string>[] = []
  const headers = tuples.shift()
  if (!headers) throw new Error("Empty tuples given")

  for (const row of tuples) {
    const record: Record<string, string> = {}
    row.forEach((val, idx) => {
      const column = headers[idx]
      // Try to JSON parse the column to check if it's a stringified array/object
      // TODO: Maybe do a String.replace() to swap any "{}" with "[]" to handle PG arrays
      try {
        const parsed = JSON.parse(val)
        record[column] = parsed
      } catch (e) {
        record[column] = val
      }
    })
    results.push(record)
  }

  return results
}

interface CreateClientParams {
  endpoint: string
  headers?: Record<string, any>
}

export const createHasuraMetadataClient = (
  config: CreateClientParams
) => async (payload: Record<string, any>) => {
  return fetch(config.endpoint, {
    method: "POST",
    headers: config.headers,
    body: JSON.stringify(payload),
  })
}

/**
 * Takes the results of querying Postgres for all of it's metadata (IE schemas, tables, cols, FK's, indices, etc.)
 * and converts it into the result object for the "postgres" GraphQL resolver/query
 */
export function postgresMetadataQueryToGQLResult(
  metadata: PostgresMetadataQueryResult
) {
  const allSchemas = Array.from(
    new Set(metadata.tables.map(it => it.table_schema))
  )

  return {
    schemas: allSchemas.map(schemaName => ({
      name: schemaName,
      tables: metadata.tables
        .filter(it => it.table_schema == schemaName)
        .map(table => ({
          table_schema: table.table_schema!,
          table_name: table.table_name!,
          comment: table.comment,
          columns: metadata.columns.filter(
            it => it.table_name == table.table_name
          ),
          primary_key: metadata.primaryKeys.find(
            it => it.table_name == table.table_name
          )!,
          foreign_keys: metadata.foreignKeys.filter(
            it => it.table_name == table.table_name
          ),
          checks: metadata.checks.filter(
            it => it.table_name == table.table_name
          ),
          indexes: metadata.indexes.filter(
            it => it.table_name == table.table_name
          ),
        })),
      views: metadata.views
        .filter(it => it.table_schema == schemaName)
        .map(view => ({
          table_schema: view.table_schema!,
          table_name: view.table_name!,
          comment: view.comment,
          columns: metadata.columns.filter(
            it => it.table_name == view.table_name
          ),
          primary_key: metadata.primaryKeys!.find(
            it => it.table_name == view.table_name
          ),
          foreign_keys: metadata.foreignKeys.filter(
            it => it.table_name == view.table_name
          ),
        })),
    })),
  }
}

export type GQLPostgresQueryResult = ReturnType<
  typeof postgresMetadataQueryToGQLResult
>
